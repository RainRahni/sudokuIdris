#!/usr/bin/chezscheme --program

;; @generated by Idris 0.6.0-464797944, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx tarm64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.so")

(let ()
(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work)])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))


(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45Types-fastPack (lambda (farg-0) (string-pack farg-0)))
(define PreludeC-45Types-fastConcat (lambda (farg-0) (string-concat farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PreludeC-45IO-prim__getString (lambda (farg-0) ((foreign-procedure "idris2_getString" (void*) string) farg-0)))
(define PrimIO-prim__nullAnyPtr (lambda (farg-0) ((foreign-procedure "idris2_isNull" (void*) int) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__seekLine (lambda (farg-0 farg-1) ((foreign-procedure "idris2_seekLine" (void*) int) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__readLine (lambda (farg-0 farg-1) ((foreign-procedure "idris2_readLine" (void*) void*) farg-0)))
(define SystemC-45FileC-45ReadWrite-prim__eof (lambda (farg-0 farg-1) ((foreign-procedure "idris2_eof" (void*) int) farg-0)))
(define SystemC-45FFI-prim__free (lambda (farg-0 farg-1) ((foreign-procedure "idris2_free" (void*) void) farg-0)))
(define SystemC-45FileC-45Error-prim__fileErrno (lambda (farg-0) ((foreign-procedure "idris2_fileErrno" () int) )))
(define SystemC-45Errno-prim__strerror (lambda (farg-0 farg-1) ((foreign-procedure "idris2_strerror" (int) string) farg-0)))
(define SystemC-45FileC-45Handle-prim__open (lambda (farg-0 farg-1 farg-2) ((foreign-procedure "idris2_openFile" (string string) void*) farg-0 farg-1)))
(define SystemC-45FileC-45Handle-prim__close (lambda (farg-0 farg-1) ((foreign-procedure "idris2_closeFile" (void*) void) farg-0)))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-2 (arg-3 ext-0))) (arg-2 act-2))))
(define csegen-7 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-8743 eta-0)))))) (lambda (u--a) (lambda (arg-9446) (lambda (eta-0) arg-9446))) (lambda (u--b) (lambda (u--a) (lambda (arg-9452) (lambda (arg-9459) (lambda (world-4) (let ((act-5 (arg-9452 world-4))) (let ((act-3 (arg-9459 world-4))) (act-5 act-3))))))))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (((let ((eff-0 (let ((e-1 (car arg-2))) e-1))) (lambda (arg-0) (lambda (arg-1) ((eff-0 arg-0) arg-1)))) u--acc) (arg-3 u--elem)))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define PreludeC-45Types-u--foldlM_Foldable_List (lambda (arg-3 arg-4 arg-5 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-3 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-4 u--b eta-0)))))) (let ((e-1 (vector-ref arg-3 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-5))) ext-0)))
(define PreludeC-45Types-u--foldr_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) ((arg-2 e-2) (PreludeC-45Types-u--foldr_Foldable_List arg-2 arg-3 e-3)))))))
(define PreludeC-45Types-u--null_Foldable_List (lambda (arg-1) (if (null? arg-1) 1 0)))
(define csegen-22 (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_List u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10426) (PreludeC-45Types-u--null_Foldable_List arg-10426))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_List i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10455) arg-10455)) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10469) (PreludeC-45Types-u--foldMap_Foldable_List i_con-0 u--f arg-10469))))))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define csegen-26 (let ((eff-0 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (PreludeC-45TypesC-45List-mapAppend '() eta-2 eta-3))))))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define PreludeC-45TypesC-45List-tailRecAppend (lambda (arg-1 arg-2) (PreludeC-45TypesC-45List-reverseOnto arg-2 (PreludeC-45TypesC-45List-reverse arg-1))))
(define csegen-37 (cons (lambda (arg-8332) (lambda (arg-8335) (PreludeC-45TypesC-45List-tailRecAppend arg-8332 arg-8335))) '()))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AllBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) arg-1) (else 0))))
(define csegen-53 (cons (lambda (arg-8332) (lambda (arg-8335) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AllBool arg-8332 arg-8335))) 1))
(define PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool (lambda (arg-0 arg-1) (cond ((equal? arg-0 1) 1) (else arg-1))))
(define PreludeC-45Types-elemBy (lambda (arg-2 arg-3 arg-4 ext-0) (let ((e-6 (vector-ref arg-2 5))) (((((e-6 'erased) 'erased) (cons (lambda (arg-8332) (lambda (arg-8335) (PreludeC-45InterfacesC-45BoolC-45Semigroup-u--C-60C-43C-62_Semigroup_AnyBool arg-8332 arg-8335))) 0)) (arg-3 arg-4)) ext-0))))
(define DataC-45List-n--4415-3930-u--nubByC-39 (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) '() (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (let ((sc1 (PreludeC-45Types-elemBy csegen-22 arg-2 e-2 arg-1))) (cond ((equal? sc1 1) (DataC-45List-n--4415-3930-u--nubByC-39 arg-1 arg-2 e-3)) (else (cons e-2 (DataC-45List-n--4415-3930-u--nubByC-39 (cons e-2 arg-1) arg-2 e-3))))))))))
(define DataC-45List-nubBy (lambda (ext-0 ext-1) (DataC-45List-n--4415-3930-u--nubByC-39 '() ext-0 ext-1)))
(define DataC-45List-nub (lambda (arg-1 ext-0) (DataC-45List-nubBy (lambda (eta-0) (lambda (eta-1) (let ((e-1 (car arg-1))) ((e-1 eta-0) eta-1)))) ext-0)))
(define PreludeC-45Types-u--C-61C-61_Eq_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2 arg-3) (if (null? arg-2) (if (null? arg-3) 1 0) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (if (null? arg-3) 0 (let ((e-6 (car arg-3))) (let ((e-7 (cdr arg-3))) (let ((sc2 (let ((e-1 (car arg-1))) ((e-1 e-2) e-6)))) (cond ((equal? sc2 1) (PreludeC-45Types-u--C-61C-61_Eq_C-40ListC-32C-36aC-41 arg-1 e-3 e-7)) (else 0)))))))))))
(define PreludeC-45Types-u--C-47C-61_Eq_Nat (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 1) 0) (else 1)))))
(define csegen-58 (cons (lambda (arg-534) (lambda (arg-537) (or (and (= arg-534 arg-537) 1) 0))) (lambda (arg-544) (lambda (arg-547) (PreludeC-45Types-u--C-47C-61_Eq_Nat arg-544 arg-547)))))
(define Main-allUnique (lambda (arg-0) (PreludeC-45Types-u--C-61C-61_Eq_C-40ListC-32C-36aC-41 csegen-58 (DataC-45List-nub csegen-58 arg-0) arg-0)))
(define PreludeC-45TypesC-45List-mapMaybeAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (let ((sc1 (arg-3 e-1))) (if (null? sc1) (PreludeC-45TypesC-45List-mapMaybeAppend arg-2 arg-3 e-2) (let ((e-3 (unbox sc1))) (PreludeC-45TypesC-45List-mapMaybeAppend (cons arg-2 e-3) arg-3 e-2)))))))))
(define DataC-45List-catMaybes (lambda (ext-0) (PreludeC-45TypesC-45List-mapMaybeAppend '() (lambda (eta-0) eta-0) ext-0)))
(define DataC-45Vect-foldrImpl (lambda (arg-3 arg-4 arg-5 arg-6) (if (null? arg-6) (arg-5 arg-4) (let ((e-3 (car arg-6))) (let ((e-4 (cdr arg-6))) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) (arg-5 ((arg-3 e-3) eta-0))) e-4))))))
(define DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4 arg-5) (DataC-45Vect-foldrImpl arg-3 arg-4 (lambda (eta-0) eta-0) arg-5)))
(define csegen-60 (lambda (eta-0) (lambda (eta-1) (cons eta-0 eta-1))))
(define DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 (lambda (ext-0) (DataC-45Vect-u--foldr_Foldable_C-40VectC-32C-36nC-41 csegen-60 '() ext-0)))
(define csegen-54 (lambda (eta-0) (Main-allUnique (DataC-45List-catMaybes (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 eta-0)))))
(define csegen-59 (csegen-26 (lambda (eta-0) (PreludeC-45Types-fastPack eta-0))))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define DataC-45Vect-drop (lambda (arg-2 arg-3) (cond ((equal? arg-2 0) arg-3)(else (let ((e-0 (- arg-2 1))) (let ((e-4 (cdr arg-3))) (DataC-45Vect-drop e-0 e-4)))))))
(define DataC-45Vect-take (lambda (arg-2 arg-3) (cond ((equal? arg-2 0) '())(else (let ((e-0 (- arg-2 1))) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (cons e-3 (DataC-45Vect-take e-0 e-4)))))))))
(define Main-n--5517-8358-u--mapM_ (lambda (arg-0 arg-3 arg-4 ext-0) (if (null? arg-4) (vector 0 ) (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (let ((act-1 ((arg-3 e-3) ext-0))) (Main-n--5517-8358-u--mapM_ arg-0 arg-3 e-4 ext-0)))))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define PreludeC-45Show-u--show_Show_Nat (lambda (arg-0) (PreludeC-45Show-u--show_Show_Integer arg-0)))
(define Main-n--5517-8359-u--printCell (lambda (arg-0 arg-1 ext-0) (if (null? arg-1) (PreludeC-45IO-prim__putStr "  " ext-0) (let ((e-1 (unbox arg-1))) (PreludeC-45IO-prim__putStr (string-append (PreludeC-45Show-u--show_Show_Nat e-1) " ") ext-0)))))
(define Main-n--5517-8360-u--printRow (lambda (arg-0 arg-1 ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "| " ext-0))) (let ((act-2 (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8359-u--printCell arg-0 eta-0 eta-1))) (DataC-45Vect-take 3 arg-1) ext-0))) (let ((act-3 (PreludeC-45IO-prim__putStr "| " ext-0))) (let ((act-4 (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8359-u--printCell arg-0 eta-0 eta-1))) (DataC-45Vect-take 3 (DataC-45Vect-drop 3 arg-1)) ext-0))) (let ((act-5 (PreludeC-45IO-prim__putStr "| " ext-0))) (let ((act-6 (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8359-u--printCell arg-0 eta-0 eta-1))) (DataC-45Vect-drop 6 arg-1) ext-0))) (PreludeC-45IO-prim__putStr "|\xa;" ext-0)))))))))
(define Main-n--5517-8361-u--printRows (lambda (arg-0 arg-1 ext-0) (let ((act-1 (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8360-u--printRow arg-0 eta-0 eta-1))) (DataC-45Vect-take 3 arg-1) ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr "+ - - - + - - - + - - - +\xa;" ext-0))) (let ((act-3 (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8360-u--printRow arg-0 eta-0 eta-1))) (DataC-45Vect-take 3 (DataC-45Vect-drop 3 arg-1)) ext-0))) (let ((act-4 (PreludeC-45IO-prim__putStr "+ - - - + - - - + - - - +\xa;" ext-0))) (Main-n--5517-8358-u--mapM_ arg-0 (lambda (eta-0) (lambda (eta-1) (Main-n--5517-8360-u--printRow arg-0 eta-0 eta-1))) (DataC-45Vect-drop 6 arg-1) ext-0)))))))
(define Main-prettyPrint (lambda (arg-0) (let ((eff-0 arg-0)) (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr "+ - - - + - - - + - - - +\xa;" world-0))) (let ((act-2 (Main-n--5517-8361-u--printRows eff-0 eff-0 world-0))) (PreludeC-45IO-prim__putStr "+ - - - + - - - + - - - +\xa;" world-0)))))))
(define PreludeC-45Interfaces-C-42C-62 (lambda (arg-3 arg-4 arg-5) (let ((e-3 (vector-ref arg-3 2))) ((((e-3 'erased) 'erased) (((let ((eff-0 (let ((e-6 (vector-ref arg-3 0))) e-6))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) (lambda (eta-0) (lambda (eta-1) eta-1))) arg-4)) arg-5))))
(define PreludeC-45Interfaces-sequence_ (lambda (arg-3 arg-4 ext-0) (let ((e-1 (vector-ref arg-4 0))) (((((e-1 'erased) 'erased) (lambda (eta-0) (lambda (eta-1) (PreludeC-45Interfaces-C-42C-62 arg-3 eta-0 eta-1)))) (let ((e-8 (vector-ref arg-3 1))) ((e-8 'erased) (vector 0 )))) ext-0))))
(define Main-case--caseC-32blockC-32inC-32main-8875 (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) (lambda (eta-0) (PreludeC-45IO-prim__putStr "No solution found.\xa;" eta-0)) (PreludeC-45Interfaces-sequence_ csegen-7 csegen-22 ((csegen-26 (lambda (eta-0) (Main-prettyPrint eta-0))) arg-2)))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define DataC-45List-drop (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) arg-2)(else (let ((e-0 (- arg-1 1))) (if (null? arg-2) '() (let ((e-4 (cdr arg-2))) (DataC-45List-drop e-0 e-4))))))))
(define DataC-45List-take (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cons e-2 (DataC-45List-take e-0 e-3))))))))))
(define Main-chunksOf (lambda (arg-1 arg-2) (if (null? arg-2) '() (cons (DataC-45List-take arg-1 arg-2) (Main-chunksOf arg-1 (DataC-45List-drop arg-1 arg-2))))))
(define DataC-45List-n--7707-7125-u--spreadHeads (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-3) arg-4 (let ((e-2 (car arg-3))) (let ((e-3 (cdr arg-3))) (if (null? arg-4) (cons (cons e-2 '()) (DataC-45List-n--7707-7125-u--spreadHeads arg-1 arg-2 e-3 '())) (let ((e-6 (car arg-4))) (let ((e-7 (cdr arg-4))) (cons (cons e-2 e-6) (DataC-45List-n--7707-7125-u--spreadHeads arg-1 arg-2 e-3 e-7))))))))))
(define DataC-45List-transpose (lambda (arg-1) (if (null? arg-1) '() (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (DataC-45List-n--7707-7125-u--spreadHeads e-2 e-3 e-2 (DataC-45List-transpose e-3)))))))
(define Main-toBlocks (lambda (arg-0) (let ((u--chunksOf3 ((csegen-26 (lambda (eta-0) (Main-chunksOf 3 (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 eta-0)))) (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 arg-0)))) (let ((u--rowsOfBlocks (PreludeC-45Types-u--foldMap_Foldable_List csegen-37 (lambda (eta-0) eta-0) ((csegen-26 (lambda (eta-0) (DataC-45List-transpose eta-0))) u--chunksOf3)))) ((csegen-26 (lambda (eta-0) (PreludeC-45Types-u--foldMap_Foldable_List csegen-37 (lambda (eta-1) eta-1) eta-0))) (Main-chunksOf 3 u--rowsOfBlocks))))))
(define DataC-45Vect-replicate (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) '())(else (let ((e-0 (- arg-1 1))) (cons arg-2 (DataC-45Vect-replicate e-0 arg-2)))))))
(define DataC-45Vect-u--zipWith_Zippable_C-40VectC-32C-36kC-41 (lambda (arg-4 arg-5 arg-6) (if (null? arg-5) '() (let ((e-3 (car arg-5))) (let ((e-4 (cdr arg-5))) (let ((e-8 (car arg-6))) (let ((e-9 (cdr arg-6))) (cons ((arg-4 e-3) e-8) (DataC-45Vect-u--zipWith_Zippable_C-40VectC-32C-36kC-41 arg-4 e-4 e-9)))))))))
(define DataC-45Vect-transpose (lambda (arg-2 arg-3) (if (null? arg-3) (DataC-45Vect-replicate arg-2 '()) (let ((e-3 (car arg-3))) (let ((e-4 (cdr arg-3))) (DataC-45Vect-u--zipWith_Zippable_C-40VectC-32C-36kC-41 (lambda (eta-0) (lambda (eta-1) (cons eta-0 eta-1))) e-3 (DataC-45Vect-transpose arg-2 e-4)))))))
(define Main-isValid (lambda (arg-0) (let ((eff-0 arg-0)) (let ((u--rows (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 eff-0))) (let ((u--cols (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 (DataC-45Vect-transpose 9 eff-0)))) (let ((u--blocks (Main-toBlocks eff-0))) (let ((sc0 (PreludeC-45Types-u--foldMap_Foldable_List csegen-53 csegen-54 u--rows))) (cond ((equal? sc0 1) (let ((sc1 (PreludeC-45Types-u--foldMap_Foldable_List csegen-53 csegen-54 u--cols))) (cond ((equal? sc1 1) (PreludeC-45Types-u--foldMap_Foldable_List csegen-53 (lambda (eta-0) (Main-allUnique (DataC-45List-catMaybes eta-0))) u--blocks)) (else 0)))) (else 0)))))))))
(define Main-forget_length (lambda (arg-2) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (let ((e-4 (cdr arg-2))) (cons e-3 (Main-forget_length e-4)))))))
(define Main-index_list (lambda (arg-1 arg-2) (if (null? arg-2) '() (cond ((equal? arg-1 0) (let ((e-2 (car arg-2))) (box e-2)))(else (let ((e-0 (- arg-1 1))) (let ((e-6 (cdr arg-2))) (Main-index_list e-0 e-6))))))))
(define Main-case--index-7720 (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-3) (box 10) (let ((e-2 (unbox arg-3))) (let ((sc1 (Main-index_list arg-1 (Main-forget_length e-2)))) (if (null? sc1) (box 10) (let ((e-3 (unbox sc1))) e-3)))))))
(define Main-index (lambda (arg-0 arg-1 arg-2) (let ((eff-0 arg-0)) (Main-case--index-7720 eff-0 arg-2 arg-1 (Main-index_list arg-1 (Main-forget_length eff-0))))))
(define DataC-45Maybe-isNothing (lambda (arg-1) (if (null? arg-1) 1 0)))
(define DataC-45Fin-with--strengthen-3777 (lambda (arg-0 arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (unbox arg-2))) (box (+ e-2 1))))))
(define DataC-45Fin-strengthen (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) '())(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (box 0))(else (let ((e-3 (- arg-1 1))) (DataC-45Fin-with--strengthen-3777 e-0 e-3 (DataC-45Fin-strengthen e-0 e-3))))))))))
(define DataC-45Fin-finS (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-0 (- arg-0 1))) (let ((sc0 (DataC-45Fin-strengthen e-0 arg-1))) (if (null? sc0) 0 (let ((e-2 (unbox sc0))) (+ e-2 1)))))))))
(define DataC-45Fin-u--C-43_Num_C-40FinC-32C-40SC-32C-36nC-41C-41 (lambda (arg-0 arg-1 arg-2) (cond ((equal? arg-1 0) arg-2)(else (cond ((equal? arg-0 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-0 (- arg-0 1))) (cond ((equal? arg-1 0) (blodwen-error-quit "Nat case not covered"))(else (let ((e-2 (- arg-1 1))) (DataC-45Fin-finS (+ (+ e-0 1) 1) (DataC-45Fin-u--C-43_Num_C-40FinC-32C-40SC-32C-36nC-41C-41 (+ e-0 1) e-2 arg-2))))))))))))
(define DataC-45Fin-u--C-61C-61_Eq_C-40FinC-32C-36nC-41 (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (cond ((equal? arg-2 0) 1)(else 0)))(else (let ((e-2 (- arg-1 1))) (cond ((equal? arg-2 0) 0)(else (let ((e-5 (- arg-2 1))) (DataC-45Fin-u--C-61C-61_Eq_C-40FinC-32C-36nC-41 e-2 e-5)))))))))
(define Main-n--5773-8624-u--search (lambda (arg-0 arg-1 arg-2) (let ((sc0 (DataC-45Fin-u--C-61C-61_Eq_C-40FinC-32C-36nC-41 arg-2 8))) (cond ((equal? sc0 1) (Main-n--5773-8624-u--search arg-0 (DataC-45Fin-u--C-43_Num_C-40FinC-32C-40SC-32C-36nC-41C-41 8 arg-1 1) 0)) (else (let ((sc1 (DataC-45Maybe-isNothing (Main-index arg-0 arg-1 arg-2)))) (cond ((equal? sc1 1) (box (cons arg-1 arg-2))) (else (Main-n--5773-8624-u--search arg-0 arg-1 (DataC-45Fin-u--C-43_Num_C-40FinC-32C-40SC-32C-36nC-41C-41 8 arg-2 1))))))))))
(define Main-findHole (lambda (arg-0) (Main-n--5773-8624-u--search arg-0 0 0)))
(define DataC-45Maybe-fromMaybe (lambda (arg-1 arg-2) (if (null? arg-2) (arg-1) (let ((e-2 (unbox arg-2))) e-2))))
(define DataC-45Maybe-isJust (lambda (arg-1) (if (null? arg-1) 0 1)))
(define DataC-45Vect-u--map_Functor_C-40VectC-32C-36nC-41 (lambda (arg-3 arg-4) (if (null? arg-4) '() (let ((e-3 (car arg-4))) (let ((e-4 (cdr arg-4))) (cons (arg-3 e-3) (((let ((eff-0 (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) (DataC-45Vect-u--map_Functor_C-40VectC-32C-36nC-41 u--func arg-8743))))))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) arg-3) e-4)))))))
(define Main-isComplete (lambda (arg-0) (let ((eff-0 arg-0)) (let ((sc0 (Main-isValid eff-0))) (cond ((equal? sc0 1) (PreludeC-45Types-u--foldMap_Foldable_List csegen-53 (lambda (eta-0) (DataC-45Maybe-isJust eta-0)) (PreludeC-45Types-u--foldMap_Foldable_List csegen-37 (lambda (eta-0) eta-0) (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 (DataC-45Vect-u--map_Functor_C-40VectC-32C-36nC-41 (lambda (eta-0) (DataC-45Vect-u--toList_Foldable_C-40VectC-32C-36nC-41 eta-0)) eff-0))))) (else 0))))))
(define Main-solve (lambda (arg-0) (let ((sc0 (Main-isValid arg-0))) (cond ((equal? sc0 1) (let ((sc1 (Main-isComplete arg-0))) (cond ((equal? sc1 1) (cons arg-0 '())) (else (Main-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32solve-8767 arg-0 (DataC-45Maybe-fromMaybe (lambda () (cons 0 0)) (Main-findHole arg-0))))))) (else '())))))
(define DataC-45Vect-index (lambda (arg-2 arg-3) (cond ((equal? arg-2 0) (let ((e-5 (car arg-3))) e-5))(else (let ((e-2 (- arg-2 1))) (let ((e-10 (cdr arg-3))) (DataC-45Vect-index e-2 e-10)))))))
(define DataC-45Vect-replaceAt (lambda (arg-2 arg-3 arg-4) (cond ((equal? arg-2 0) (let ((e-6 (cdr arg-4))) (cons arg-3 e-6)))(else (let ((e-2 (- arg-2 1))) (let ((e-9 (car arg-4))) (let ((e-10 (cdr arg-4))) (cons e-9 (DataC-45Vect-replaceAt e-2 arg-3 e-10)))))))))
(define Main-update (lambda (arg-0 arg-1 arg-2 arg-3) (let ((eff-0 arg-0)) (let ((u--newRow (DataC-45Vect-replaceAt arg-1 (DataC-45Vect-replaceAt arg-2 (box arg-3) (DataC-45Vect-index arg-1 eff-0)) eff-0))) u--newRow))))
(define Main-case--caseC-32blockC-32inC-32caseC-32blockC-32inC-32solve-8767 (lambda (arg-0 arg-1) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (let ((u--possibleDigitsList (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--n) (Main-isValid (Main-update arg-0 e-2 e-3 u--n))) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 (cons 6 (cons 7 (cons 8 (cons 9 '())))))))))))) (PreludeC-45Types-u--foldMap_Foldable_List csegen-37 (lambda (u--n) (Main-solve (Main-update arg-0 e-2 e-3 u--n))) u--possibleDigitsList))))))
(define Main-fromList9 (lambda (arg-1) (if (null? arg-1) '() (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (if (null? e-2) '() (let ((e-4 (car e-2))) (let ((e-5 (cdr e-2))) (if (null? e-5) '() (let ((e-7 (car e-5))) (let ((e-8 (cdr e-5))) (if (null? e-8) '() (let ((e-10 (car e-8))) (let ((e-11 (cdr e-8))) (if (null? e-11) '() (let ((e-13 (car e-11))) (let ((e-14 (cdr e-11))) (if (null? e-14) '() (let ((e-16 (car e-14))) (let ((e-17 (cdr e-14))) (if (null? e-17) '() (let ((e-19 (car e-17))) (let ((e-20 (cdr e-17))) (if (null? e-20) '() (let ((e-22 (car e-20))) (let ((e-23 (cdr e-20))) (if (null? e-23) '() (let ((e-25 (car e-23))) (let ((e-26 (cdr e-23))) (if (null? e-26) (box (cons e-1 (cons e-4 (cons e-7 (cons e-10 (cons e-13 (cons e-16 (cons e-19 (cons e-22 (cons e-25 '())))))))))) '()))))))))))))))))))))))))))))))
(define Main-case--parseTable-8251 (lambda (arg-0 arg-1 arg-2) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-2 1))) (let ((sc1 (Main-fromList9 e-5))) (if (null? sc1) (vector 0 "Invalid table: must contain exactly 9 rows") (let ((e-1 (unbox sc1))) (vector 1 e-1)))))))))
(define DataC-45String-n--3923-7830-u--linesHelp (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) (if (null? arg-2) '() (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3923-7830-u--linesHelp arg-0 (cons e-2 arg-1) e-3))))))) (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3923-7830-u--linesHelp arg-0 (cons e-2 arg-1) e-3)))))))))
(define DataC-45String-linesC-39 (lambda (arg-0) (DataC-45String-n--3923-7830-u--linesHelp arg-0 '() arg-0)))
(define DataC-45String-lines (lambda (arg-0) (csegen-59 (DataC-45String-linesC-39 (PreludeC-45Types-fastUnpack arg-0)))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define Main-parseCell (lambda (arg-0) (cond ((equal? arg-0 ".") '())(else (box (PreludeC-45Types-prim__integerToNat (cast-string-int arg-0)))))))
(define PreludeC-45Types-isSpace (lambda (arg-0) (cond ((equal? arg-0 #\ ) 1) ((equal? arg-0 (integer->char 9)) 1) ((equal? arg-0 (integer->char 13)) 1) ((equal? arg-0 (integer->char 10)) 1) ((equal? arg-0 (integer->char 12)) 1) ((equal? arg-0 (integer->char 11)) 1) ((equal? arg-0 (integer->char 160)) 1)(else 0))))
(define DataC-45String-n--3818-7730-u--wordsHelper (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) arg-2 (cons arg-2 (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '())))))
(define DataC-45String-n--3818-7731-u--wordsC-39 (lambda (arg-0 arg-1 arg-2 arg-3) (if (null? arg-1) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 (DataC-45String-n--3818-7730-u--wordsHelper arg-0 arg-2 arg-3) '()) (let ((e-1 (car arg-1))) (let ((e-2 (cdr arg-1))) (let ((sc1 (PreludeC-45Types-isSpace e-1))) (cond ((equal? sc1 1) (DataC-45String-n--3818-7731-u--wordsC-39 arg-0 e-2 '() (DataC-45String-n--3818-7730-u--wordsHelper arg-0 arg-2 arg-3))) (else (DataC-45String-n--3818-7731-u--wordsC-39 arg-0 e-2 (cons arg-2 e-1) arg-3)))))))))
(define DataC-45String-words (lambda (arg-0) (csegen-59 (DataC-45String-n--3818-7731-u--wordsC-39 arg-0 (PreludeC-45Types-fastUnpack arg-0) '() '()))))
(define Main-parseRow (lambda (arg-0) (let ((sc0 (Main-fromList9 ((csegen-26 (lambda (eta-0) (Main-parseCell eta-0))) (DataC-45String-words arg-0))))) (if (null? sc0) (vector 0 "Invalid row: must contain exactly 9 cells") (let ((e-1 (unbox sc0))) (vector 1 e-1))))))
(define PreludeC-45Types-u--traverse_Traversable_List (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) '())) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((e-4 (vector-ref arg-3 2))) ((((e-4 'erased) 'erased) (let ((e-6 (vector-ref arg-3 2))) ((((e-6 'erased) 'erased) (let ((e-10 (vector-ref arg-3 1))) ((e-10 'erased) csegen-60))) (arg-4 e-2)))) (PreludeC-45Types-u--traverse_Traversable_List arg-3 arg-4 e-3))))))))
(define Main-parseTable (lambda (arg-0) (let ((u--rows ((csegen-26 (lambda (eta-0) (Main-parseRow eta-0))) (DataC-45String-lines arg-0)))) (Main-case--parseTable-8251 arg-0 u--rows (PreludeC-45Types-u--traverse_Traversable_List (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) (case (vector-ref arg-8743 0) ((0) (let ((e-2 (vector-ref arg-8743 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-8743 1))) (vector 1 (u--func e-5))))))))) (lambda (u--a) (lambda (arg-9446) (vector 1 arg-9446))) (lambda (u--b) (lambda (u--a) (lambda (arg-9452) (lambda (arg-9459) (case (vector-ref arg-9452 0) ((0) (let ((e-2 (vector-ref arg-9452 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-9452 1))) (case (vector-ref arg-9459 0) ((1) (let ((e-8 (vector-ref arg-9459 1))) (vector 1 (e-5 e-8)))) (else (let ((e-11 (vector-ref arg-9459 1))) (vector 0 e-11)))))))))))) (lambda (eta-0) eta-0) u--rows)))))
(define DataC-45Fuel-forever (lambda () (box (lambda () (DataC-45Fuel-forever)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45FileC-45ReadWrite-fEOF (lambda (arg-1 arg-2) (let ((eff-0 arg-2)) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__eof eff-0 eta-0))))) (lambda (u--res) (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (PreludeC-45EqOrd-u--C-47C-61_Eq_Int u--res (blodwen-toSignedInt 0 63)))))))))))))
(define SystemC-45FFI-free (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FFI-prim__free arg-2 eta-0))))))
(define SystemC-45FileC-45Support-ok (lambda (arg-3 arg-4) (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) (vector 1 arg-4)))))))
(define PrimIO-prim__forgetPtr (lambda (ext-0) ext-0))
(define SystemC-45FileC-45Error-returnError (lambda (arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Error-prim__fileErrno eta-0))))) (lambda (u--err) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (vector 0 (cond ((equal? u--err 0) (vector 1 )) ((equal? u--err 1) (vector 2 )) ((equal? u--err 2) (vector 3 )) ((equal? u--err 3) (vector 4 )) ((equal? u--err 4) (vector 5 ))(else (vector 0 (bs- u--err 5 63)))))))))))))))
(define SystemC-45FileC-45ReadWrite-getStringAndFree (lambda (arg-1 arg-2) (let ((sc0 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr (PrimIO-prim__forgetPtr arg-2)) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (let ((u--s (PreludeC-45IO-prim__getString arg-2))) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FFI-free arg-1 (PrimIO-prim__forgetPtr arg-2))) (lambda (_-10164) (SystemC-45FileC-45Support-ok arg-1 u--s)))))))))))
(define SystemC-45FileC-45ReadWrite-fGetLine (lambda (arg-1 arg-2) (let ((eff-0 arg-2)) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__readLine eff-0 eta-0))))) (lambda (u--res) (SystemC-45FileC-45ReadWrite-getStringAndFree arg-1 u--res))))))))
(define SystemC-45FileC-45ReadWrite-fSeekLine (lambda (arg-1 arg-2) (let ((eff-0 arg-2)) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-prim__seekLine eff-0 eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int u--res (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 (vector 0 ))))))))))))
(define PreludeC-45InterfacesC-45Applicative-u--C-60C-42C-62_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (lambda (arg-4 arg-5 arg-6 arg-7) (let ((e-3 (vector-ref arg-4 2))) ((((e-3 'erased) 'erased) (let ((e-4 (vector-ref arg-4 2))) ((((e-4 'erased) 'erased) (let ((e-8 (vector-ref arg-4 1))) ((e-8 'erased) (lambda (clam-0) (lambda (clam-1) (let ((e-10 (vector-ref arg-5 2))) ((((e-10 'erased) 'erased) clam-0) clam-1))))))) arg-6))) arg-7))))
(define PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 (lambda (arg-3 arg-4) (case (vector-ref arg-3 0) ((0) (let ((e-2 (vector-ref arg-3 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref arg-3 1))) (arg-4 e-5))))))
(define PreludeC-45InterfacesC-45Monad-u--C-62C-62C-61_Monad_ComposeC-40C-40C-46C-32C-36mC-41C-32C-36tC-41 (lambda (arg-4 arg-5 arg-6 arg-7 arg-8) (let ((e-2 (vector-ref arg-4 1))) ((((e-2 'erased) 'erased) arg-7) (lambda (eta-0) (((let ((eff-0 (let ((e-6 (vector-ref arg-4 0))) (let ((e-9 (vector-ref e-6 0))) e-9)))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) (lambda (clam-0) (let ((e-4 (vector-ref arg-5 2))) ((e-4 'erased) clam-0)))) (let ((e-4 (vector-ref arg-6 2))) ((((((e-4 'erased) 'erased) 'erased) (let ((e-9 (vector-ref arg-4 0))) e-9)) arg-8) eta-0))))))))
(define PreludeC-45Types-u--foldr_Foldable_C-40EitherC-32C-36eC-41 (lambda (arg-3 arg-4 arg-5) (case (vector-ref arg-5 0) ((0) arg-4) (else (let ((e-5 (vector-ref arg-5 1))) ((arg-3 e-5) arg-4))))))
(define PreludeC-45Types-u--foldMap_Foldable_C-40EitherC-32C-36eC-41 (lambda (arg-3 arg-4 ext-0) (PreludeC-45Types-u--foldr_Foldable_C-40EitherC-32C-36eC-41 (lambda (eta-0) ((let ((eff-0 (let ((e-1 (car arg-3))) e-1))) (lambda (arg-0) (lambda (arg-1) ((eff-0 arg-0) arg-1)))) (arg-4 eta-0))) (let ((e-2 (cdr arg-3))) e-2) ext-0)))
(define PreludeC-45Types-u--foldl_Foldable_C-40EitherC-32C-36eC-41 (lambda (arg-3 arg-4 arg-5) ((PreludeC-45Types-u--foldr_Foldable_C-40EitherC-32C-36eC-41 (lambda (eta-0) (lambda (eta-1) (PreludeC-45Basics-flip (lambda (eta-2) (lambda (eta-3) (lambda (eta-4) (eta-2 (eta-3 eta-4))))) (lambda (eta-2) (PreludeC-45Basics-flip arg-3 eta-0 eta-2)) eta-1))) (lambda (eta-0) eta-0) arg-5) arg-4)))
(define PreludeC-45Types-u--foldlM_Foldable_C-40EitherC-32C-36eC-41 (lambda (arg-4 arg-5 arg-6 ext-0) (PreludeC-45Types-u--foldl_Foldable_C-40EitherC-32C-36eC-41 (lambda (u--ma) (lambda (u--b) (let ((e-2 (vector-ref arg-4 1))) ((((e-2 'erased) 'erased) u--ma) (lambda (eta-0) (PreludeC-45Basics-flip arg-5 u--b eta-0)))))) (let ((e-1 (vector-ref arg-4 0))) (let ((e-5 (vector-ref e-1 1))) ((e-5 'erased) arg-6))) ext-0)))
(define PreludeC-45Types-u--join_Monad_C-40EitherC-32C-36eC-41 (lambda (arg-2) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 arg-2 (lambda (eta-0) eta-0))))
(define PreludeC-45InterfacesC-45Functor-u--map_Functor_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (lambda (arg-4 arg-5 ext-0) ((let ((eff-0 arg-4)) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) ((let ((eff-0 arg-5)) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) ext-0))))
(define PreludeC-45Types-u--null_Foldable_C-40EitherC-32C-36eC-41 (lambda (arg-2) (case (vector-ref arg-2 0) ((0) 1) (else 0))))
(define PreludeC-45InterfacesC-45Applicative-u--pure_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (lambda (arg-3 arg-4 ext-0) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) (let ((e-5 (vector-ref arg-4 1))) ((e-5 'erased) ext-0))))))
(define PreludeC-45Types-u--toList_Foldable_C-40EitherC-32C-36eC-41 (lambda (ext-0) (PreludeC-45Types-u--foldr_Foldable_C-40EitherC-32C-36eC-41 csegen-60 '() ext-0)))
(define PreludeC-45Types-u--traverse_Traversable_C-40EitherC-32C-36eC-41 (lambda (arg-4 arg-5 arg-6) (case (vector-ref arg-6 0) ((0) (let ((e-2 (vector-ref arg-6 1))) (let ((e-4 (vector-ref arg-4 1))) ((e-4 'erased) (vector 0 e-2))))) (else (let ((e-5 (vector-ref arg-6 1))) (((let ((eff-0 (let ((e-1 (vector-ref arg-4 0))) e-1))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) (lambda (eta-0) (vector 1 eta-0))) (arg-5 e-5)))))))
(define SystemC-45FileC-45ReadWrite-readLinesOnto (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (if (null? arg-4) (let ((e-1 (car arg-1))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) (vector 1 (cons 0 (PreludeC-45TypesC-45List-reverse arg-2))))))) (let ((e-0 (unbox arg-4))) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FileC-45ReadWrite-fEOF arg-1 arg-5)) (lambda (_-0) (cond ((equal? _-0 0) (cond ((equal? arg-3 0) (PreludeC-45InterfacesC-45Monad-u--C-62C-62C-61_Monad_ComposeC-40C-40C-46C-32C-36mC-41C-32C-36tC-41 (let ((e-7 (car arg-1))) e-7) (vector (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) (case (vector-ref arg-8743 0) ((0) (let ((e-6 (vector-ref arg-8743 1))) (vector 0 e-6))) (else (let ((e-6 (vector-ref arg-8743 1))) (vector 1 (u--func e-6))))))))) (lambda (u--a) (lambda (arg-9446) (vector 1 arg-9446))) (lambda (u--b) (lambda (u--a) (lambda (arg-9452) (lambda (arg-9459) (case (vector-ref arg-9452 0) ((0) (let ((e-6 (vector-ref arg-9452 1))) (vector 0 e-6))) (else (let ((e-6 (vector-ref arg-9452 1))) (case (vector-ref arg-9459 0) ((1) (let ((e-8 (vector-ref arg-9459 1))) (vector 1 (e-6 e-8)))) (else (let ((e-11 (vector-ref arg-9459 1))) (vector 0 e-11)))))))))))) (lambda (u--b) (lambda (u--a) (lambda (arg-9926) (lambda (arg-9929) (PreludeC-45Types-u--C-62C-62C-61_Monad_C-40EitherC-32C-36eC-41 arg-9926 arg-9929))))) (lambda (u--a) (lambda (arg-9940) (PreludeC-45Types-u--join_Monad_C-40EitherC-32C-36eC-41 arg-9940)))) (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) (case (vector-ref arg-8743 0) ((0) (let ((e-6 (vector-ref arg-8743 1))) (vector 0 e-6))) (else (let ((e-6 (vector-ref arg-8743 1))) (vector 1 (u--func e-6))))))))) (vector (lambda (u--acc) (lambda (u--elem) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldr_Foldable_C-40EitherC-32C-36eC-41 u--func u--init u--input)))))) (lambda (u--elem) (lambda (u--acc) (lambda (u--func) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldl_Foldable_C-40EitherC-32C-36eC-41 u--func u--init u--input)))))) (lambda (u--elem) (lambda (arg-10426) (PreludeC-45Types-u--null_Foldable_C-40EitherC-32C-36eC-41 arg-10426))) (lambda (u--elem) (lambda (u--acc) (lambda (u--m) (lambda (i_con-0) (lambda (u--funcM) (lambda (u--init) (lambda (u--input) (PreludeC-45Types-u--foldlM_Foldable_C-40EitherC-32C-36eC-41 i_con-0 u--funcM u--init u--input)))))))) (lambda (u--elem) (lambda (arg-10455) (PreludeC-45Types-u--toList_Foldable_C-40EitherC-32C-36eC-41 arg-10455))) (lambda (u--a) (lambda (u--m) (lambda (i_con-0) (lambda (u--f) (lambda (arg-10469) (PreludeC-45Types-u--foldMap_Foldable_C-40EitherC-32C-36eC-41 i_con-0 u--f arg-10469))))))) (lambda (u--b) (lambda (u--a) (lambda (u--f) (lambda (i_con-0) (lambda (arg-13244) (lambda (arg-13251) (PreludeC-45Types-u--traverse_Traversable_C-40EitherC-32C-36eC-41 i_con-0 arg-13244 arg-13251)))))))) (SystemC-45FileC-45ReadWrite-fGetLine arg-1 arg-5) (lambda (u--str) (SystemC-45FileC-45ReadWrite-readLinesOnto arg-1 (cons u--str arg-2) 0 (e-0) arg-5))))(else (let ((e-6 (- arg-3 1))) (PreludeC-45Interfaces-C-42C-62 (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8743) ((PreludeC-45InterfacesC-45Functor-u--map_Functor_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (let ((e-8 (car arg-1))) (let ((e-11 (vector-ref e-8 0))) (let ((e-14 (vector-ref e-11 0))) e-14))) (lambda (b-0) (lambda (a-0) (lambda (func-0) (lambda (arg-8744) (case (vector-ref arg-8744 0) ((0) (let ((e-7 (vector-ref arg-8744 1))) (vector 0 e-7))) (else (let ((e-7 (vector-ref arg-8744 1))) (vector 1 (func-0 e-7))))))))) u--func) arg-8743))))) (lambda (u--a) (lambda (arg-9446) (PreludeC-45InterfacesC-45Applicative-u--pure_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (let ((e-8 (car arg-1))) (let ((e-11 (vector-ref e-8 0))) e-11)) (vector (lambda (u--b) (lambda (a-0) (lambda (u--func) (lambda (arg-8743) (case (vector-ref arg-8743 0) ((0) (let ((e-7 (vector-ref arg-8743 1))) (vector 0 e-7))) (else (let ((e-7 (vector-ref arg-8743 1))) (vector 1 (u--func e-7))))))))) (lambda (a-0) (lambda (arg-9447) (vector 1 arg-9447))) (lambda (u--b) (lambda (a-0) (lambda (arg-9452) (lambda (arg-9459) (case (vector-ref arg-9452 0) ((0) (let ((e-7 (vector-ref arg-9452 1))) (vector 0 e-7))) (else (let ((e-7 (vector-ref arg-9452 1))) (case (vector-ref arg-9459 0) ((1) (let ((e-8 (vector-ref arg-9459 1))) (vector 1 (e-7 e-8)))) (else (let ((e-11 (vector-ref arg-9459 1))) (vector 0 e-11)))))))))))) arg-9446))) (lambda (u--b) (lambda (u--a) (lambda (arg-9452) (lambda (arg-9459) (PreludeC-45InterfacesC-45Applicative-u--C-60C-42C-62_Applicative_ComposeC-40C-40C-46C-32C-36fC-41C-32C-36gC-41 (let ((e-8 (car arg-1))) (let ((e-11 (vector-ref e-8 0))) e-11)) (vector (lambda (b-0) (lambda (a-0) (lambda (u--func) (lambda (arg-8743) (case (vector-ref arg-8743 0) ((0) (let ((e-7 (vector-ref arg-8743 1))) (vector 0 e-7))) (else (let ((e-7 (vector-ref arg-8743 1))) (vector 1 (u--func e-7))))))))) (lambda (a-0) (lambda (arg-9446) (vector 1 arg-9446))) (lambda (b-0) (lambda (a-0) (lambda (arg-9453) (lambda (arg-9460) (case (vector-ref arg-9453 0) ((0) (let ((e-7 (vector-ref arg-9453 1))) (vector 0 e-7))) (else (let ((e-7 (vector-ref arg-9453 1))) (case (vector-ref arg-9460 0) ((1) (let ((e-8 (vector-ref arg-9460 1))) (vector 1 (e-7 e-8)))) (else (let ((e-11 (vector-ref arg-9460 1))) (vector 0 e-11)))))))))))) arg-9452 arg-9459)))))) (SystemC-45FileC-45ReadWrite-fSeekLine arg-1 arg-5) (SystemC-45FileC-45ReadWrite-readLinesOnto arg-1 arg-2 e-6 (box e-0) arg-5)))))) (else (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (vector 1 (cons 1 (PreludeC-45TypesC-45List-reverse arg-2)))))))))))))))))
(define SystemC-45FileC-45Handle-closeFile (lambda (arg-1 arg-2) (let ((eff-0 arg-2)) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__close eff-0 eta-0)))))))
(define PreludeC-45Types-elem (lambda (arg-2 arg-3 ext-1 ext-0) (PreludeC-45Types-elemBy arg-2 (lambda (eta-0) (lambda (eta-1) (let ((e-1 (car arg-3))) ((e-1 eta-0) eta-1)))) ext-1 ext-0)))
(define SystemC-45Info-os (blodwen-os))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define SystemC-45Info-isWindows (PreludeC-45Types-elem csegen-22 (cons (lambda (arg-534) (lambda (arg-537) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-534 arg-537))) (lambda (arg-544) (lambda (arg-547) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-544 arg-547)))) SystemC-45Info-os (cons "windows" (cons "mingw32" (cons "cygwin32" '())))))
(define SystemC-45FileC-45Mode-modeStr (lambda (arg-0) (cond ((equal? arg-0 0) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb") (else "r")))) ((equal? arg-0 1) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb") (else "w")))) ((equal? arg-0 2) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab") (else "a")))) ((equal? arg-0 3) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "rb+") (else "r+")))) ((equal? arg-0 4) (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "wb+") (else "w+")))) (else (let ((sc1 SystemC-45Info-isWindows)) (cond ((equal? sc1 1) "ab+") (else "a+")))))))
(define SystemC-45FileC-45Handle-openFile (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (SystemC-45FileC-45Handle-prim__open arg-2 (SystemC-45FileC-45Mode-modeStr arg-3) eta-0))))) (lambda (u--res) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_Int (PrimIO-prim__nullAnyPtr u--res) (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (SystemC-45FileC-45Error-returnError arg-1)) (else (SystemC-45FileC-45Support-ok arg-1 u--res))))))))))
(define SystemC-45FileC-45Handle-withFile (lambda (arg-3 arg-4 arg-5 arg-6 arg-7) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (SystemC-45FileC-45Handle-openFile arg-3 arg-4 arg-5)) (lambda (_-0) (case (vector-ref _-0 0) ((1) (let ((e-6 (vector-ref _-0 1))) (let ((e-8 (car arg-3))) (let ((e-10 (vector-ref e-8 1))) ((((e-10 'erased) 'erased) (arg-7 e-6)) (lambda (u--res) (let ((e-13 (car arg-3))) (let ((e-15 (vector-ref e-13 1))) ((((e-15 'erased) 'erased) (SystemC-45FileC-45Handle-closeFile arg-3 e-6)) (lambda (_-10164) (let ((e-18 (car arg-3))) (let ((e-21 (vector-ref e-18 0))) (let ((e-23 (vector-ref e-21 1))) ((e-23 'erased) u--res)))))))))))))) (else (let ((e-6 (vector-ref _-0 1))) (((let ((eff-0 (let ((e-8 (car arg-3))) (let ((e-11 (vector-ref e-8 0))) (let ((e-14 (vector-ref e-11 0))) e-14))))) (lambda (arg-0) (lambda (arg-1) ((((eff-0 'erased) 'erased) arg-0) arg-1)))) (lambda (eta-0) (vector 0 eta-0))) (arg-6 e-6)))))))))))
(define SystemC-45FileC-45ReadWrite-readFilePage (lambda (arg-1 arg-2 arg-3 arg-4) (SystemC-45FileC-45Handle-withFile arg-1 arg-4 0 (lambda (eta-0) (let ((e-1 (car arg-1))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) eta-0))))) (lambda (eta-0) (SystemC-45FileC-45ReadWrite-readLinesOnto arg-1 '() arg-2 arg-3 eta-0)))))
(define Builtin-snd (lambda (arg-2) (let ((e-3 (cdr arg-2))) e-3)))
(define SystemC-45FileC-45ReadWrite-readFile (lambda (arg-1 ext-0) (((let ((eff-0 (let ((e-1 (car arg-1))) (let ((e-5 (vector-ref e-1 0))) (let ((e-8 (vector-ref e-5 0))) e-8))))) (lambda (arg-0) (lambda (arg-2) ((((eff-0 'erased) 'erased) arg-0) arg-2)))) ((let ((eff-0 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (case (vector-ref eta-3 0) ((0) (let ((e-2 (vector-ref eta-3 1))) (vector 0 e-2))) (else (let ((e-5 (vector-ref eta-3 1))) (vector 1 (eta-2 e-5))))))))))) (lambda (arg-0) (lambda (arg-2) ((((eff-0 'erased) 'erased) arg-0) arg-2)))) (lambda (eta-0) (PreludeC-45Types-fastConcat (Builtin-snd eta-0))))) (SystemC-45FileC-45ReadWrite-readFilePage arg-1 0 (DataC-45Fuel-forever) ext-0))))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (let ((eff-0 arg-1)) (PrimIO-unsafeCreateWorld (lambda (u--w) (let ((eff-1 (eff-0 u--w))) eff-1))))))
(define SystemC-45Errno-strerror (lambda (arg-0) (PrimIO-unsafePerformIO (lambda (eta-0) (SystemC-45Errno-prim__strerror arg-0 eta-0)))))
(define SystemC-45FileC-45Error-u--show_Show_FileError (lambda (arg-0) (case (vector-ref arg-0 0) ((0) (let ((e-0 (vector-ref arg-0 1))) (SystemC-45Errno-strerror e-0))) ((1) "File Read Error") ((2) "File Write Error") ((3) "File Not Found") ((4) "Permission Denied") (else "File Exists"))))
(define Main-readSudokuFile (lambda (arg-0 ext-0) (let ((act-1 ((SystemC-45FileC-45ReadWrite-readFile (cons (vector csegen-7 (lambda (u--b) (lambda (u--a) (lambda (arg-9926) (lambda (arg-9929) (lambda (world-0) (let ((act-1 (arg-9926 world-0))) ((arg-9929 act-1) world-0))))))) (lambda (u--a) (lambda (arg-9940) (lambda (world-0) (let ((act-1 (arg-9940 world-0))) (act-1 world-0)))))) (lambda (u--a) (lambda (arg-12953) arg-12953))) arg-0) ext-0))) (case (vector-ref act-1 0) ((0) (let ((e-2 (vector-ref act-1 1))) (vector 0 (SystemC-45FileC-45Error-u--show_Show_FileError e-2)))) (else (let ((e-5 (vector-ref act-1 1))) (Main-parseTable e-5)))))))
(define Main-main (lambda (ext-0) (let ((act-1 (Main-readSudokuFile "parserTest.txt" ext-0))) (case (vector-ref act-1 0) ((0) (let ((e-2 (vector-ref act-1 1))) (PreludeC-45IO-prim__putStr (string-append e-2 "\xa;") ext-0))) (else (let ((e-5 (vector-ref act-1 1))) (let ((u--result (vector 1 e-5))) ((Main-case--caseC-32blockC-32inC-32main-8875 e-5 u--result (Main-solve e-5)) ext-0))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(collect-request-handler (lambda () (collect) (blodwen-run-finalisers)))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))
  (collect 4)
  (blodwen-run-finalisers)
  
  )